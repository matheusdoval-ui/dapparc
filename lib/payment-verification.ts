/**
 * Payment verification for leaderboard access
 * Checks if a wallet has paid the required fee to appear in the leaderboard
 */

import { JsonRpcProvider, Contract } from 'ethers'

// ARC Testnet Configuration
const ARC_RPC_URL = process.env.ARC_RPC_URL || 'https://rpc.testnet.arc.network'

// Developer wallet address (recipient of payment)
export const DEVELOPER_WALLET = '0xc8d7F8ffB0c98f6157E4bF684bE7756f2CddeBF2'.toLowerCase()

// Payment contract address (if deployed, otherwise use direct transfers)
// Set this environment variable after deploying the contract
export const PAYMENT_CONTRACT = process.env.PAYMENT_CONTRACT_ADDRESS?.toLowerCase()

// Token contract addresses (USDC and EURC on ARC Testnet)
const USDC_CONTRACT = '0x3910B7cbb3341f1F4bF4cEB66e4A2C8f204FE2b8'.toLowerCase()
const EURC_CONTRACT = '0x89B50855Aa3bE2F677cD6303Cec089B5F319D72a'.toLowerCase()

// Minimum payment required: 0.5 USDC or EURC (6 decimals, so 0.5 * 1e6)
const MINIMUM_PAYMENT_AMOUNT = BigInt('500000') // 0.5 * 10^6 = 500000 (6 decimals)

// ERC-20 Transfer event signature: Transfer(address,address,uint256)
const TRANSFER_EVENT_SIGNATURE = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'

// PaymentReceived event signature from LeaderboardPayment contract
// PaymentReceived(address indexed payer, address indexed token, uint256 amount, uint256 timestamp)
// keccak256("PaymentReceived(address,address,uint256,uint256)")
// Calculated: keccak256("PaymentReceived(address,address,uint256,uint256)")
// Note: This will be calculated correctly when contract is deployed
// For now, we'll use a placeholder - the actual hash will be generated by Solidity compiler
const PAYMENT_RECEIVED_EVENT_SIGNATURE = '0x' // Will be set after contract deployment

// Cache for payment verification (to avoid repeated RPC calls)
const paymentCache = new Map<string, { paid: boolean; timestamp: number }>()
const CACHE_TTL = 10 * 60 * 1000 // 10 minutes

/**
 * Check if a wallet has paid the required fee to the developer wallet
 * Verifies by checking transaction history for transfers to developer address
 */
export async function hasPaidLeaderboardFee(walletAddress: string): Promise<boolean> {
  const normalizedAddress = walletAddress.toLowerCase()
  
  // Check cache first
  const cached = paymentCache.get(normalizedAddress)
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    console.log(`üíæ Using cached payment status for ${normalizedAddress}: ${cached.paid}`)
    return cached.paid
  }

  try {
    const provider = new JsonRpcProvider(ARC_RPC_URL)
    
    let hasPaid = false
    
    // First, try to check via payment contract if deployed
    if (PAYMENT_CONTRACT) {
      try {
        console.log(`üîç Checking payment via contract: ${PAYMENT_CONTRACT}`)
        const contract = new Contract(
          PAYMENT_CONTRACT,
          ['function hasPaid(address) view returns (bool)'],
          provider
        )
        hasPaid = await contract.hasPaid(normalizedAddress)
        
        if (hasPaid) {
          console.log(`‚úÖ Payment verified via contract for ${normalizedAddress}`)
          paymentCache.set(normalizedAddress, { paid: true, timestamp: Date.now() })
          return true
        }
      } catch (contractError: any) {
        console.warn(`‚ö†Ô∏è Error checking payment contract, falling back to event logs:`, contractError.message)
        // Fall through to event log checking
      }
    }
    
    // Fallback: Check via event logs (direct transfers or contract events)
    const latestBlock = await provider.getBlockNumber()
    const blocksToScan = Math.min(2000, latestBlock)
    const scanStartBlock = Math.max(0, latestBlock - blocksToScan)
    
    console.log(`üîç Checking payment events for ${normalizedAddress} from block ${scanStartBlock} to ${latestBlock}`)
    
    // Check PaymentReceived events from contract (if deployed)
    // Note: Event checking will work once contract is deployed and event signature is known
    // For now, we rely on the hasPaid() function which is more reliable
    
    // Also check direct token transfers to developer wallet (fallback)
    if (!hasPaid) {
      const tokenContracts = [
        { address: USDC_CONTRACT, name: 'USDC' },
        { address: EURC_CONTRACT, name: 'EURC' }
      ]
      
      const fromAddressTopic = `0x${normalizedAddress.slice(2).padStart(64, '0')}`
      const toAddressTopic = `0x${DEVELOPER_WALLET.slice(2).padStart(64, '0')}`
      
      for (const token of tokenContracts) {
        if (hasPaid) break
        
        try {
          console.log(`üîç Checking ${token.name} transfers from ${normalizedAddress} to ${DEVELOPER_WALLET}`)
          
          const logs = await provider.send('eth_getLogs', [{
            fromBlock: `0x${scanStartBlock.toString(16)}`,
            toBlock: 'latest',
            address: token.address,
            topics: [
              TRANSFER_EVENT_SIGNATURE,
              fromAddressTopic,
              toAddressTopic,
            ]
          }])
          
          if (logs && Array.isArray(logs) && logs.length > 0) {
            console.log(`üìã Found ${logs.length} ${token.name} Transfer event(s)`)
            
            for (const log of logs) {
              try {
                const valueHex = log.data || '0x0'
                const value = BigInt(valueHex)
                
                console.log(`üí∞ ${token.name} transfer amount: ${value.toString()} (${Number(value) / 1e6} ${token.name})`)
                
                if (value >= MINIMUM_PAYMENT_AMOUNT) {
                  console.log(`‚úÖ Found valid payment: ${Number(value) / 1e6} ${token.name} in tx ${log.transactionHash}`)
                  hasPaid = true
                  break
                }
              } catch (err) {
                console.warn(`‚ö†Ô∏è Error decoding transfer log:`, err)
                continue
              }
            }
          }
        } catch (tokenError: any) {
          console.warn(`‚ö†Ô∏è Error checking ${token.name} transfers:`, tokenError.message || tokenError)
          continue
        }
      }
    }
    
    // Cache the result
    paymentCache.set(normalizedAddress, { paid: hasPaid, timestamp: Date.now() })
    
    if (hasPaid) {
      console.log(`‚úÖ Payment verified for ${normalizedAddress}`)
    } else {
      console.log(`‚ùå No payment found for ${normalizedAddress}`)
    }
    
    return hasPaid
  } catch (error) {
    console.error(`‚ùå Error checking payment for ${normalizedAddress}:`, error)
    // On error, assume not paid (fail secure)
    paymentCache.set(normalizedAddress, { paid: false, timestamp: Date.now() })
    return false
  }
}

/**
 * Clear payment cache (useful for testing or forced refresh)
 */
export function clearPaymentCache(): void {
  paymentCache.clear()
  console.log('üóëÔ∏è Payment cache cleared')
}
